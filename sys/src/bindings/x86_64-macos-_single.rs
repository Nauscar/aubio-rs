/* automatically generated by rust-bindgen 0.70.1 */

pub const HAVE_AUBIO_DOUBLE: u32 = 0;
pub const AUBIO_SMPL_FMT: &[u8; 3] = b"%f\0";
pub const AUBIO_LSMP_FMT: &[u8; 4] = b"%lf\0";
pub type smpl_t = f32;
pub type lsmp_t = f64;
#[doc = " unsigned integer"]
pub type uint_t = ::std::os::raw::c_uint;
#[doc = " signed integer"]
pub type sint_t = ::std::os::raw::c_int;
#[doc = " character"]
pub type char_t = ::std::os::raw::c_char;
#[doc = " Buffer for real data\n\nVector of real-valued data\n\n::fvec_t is is the structure used to store vector of real-valued data, ::smpl_t .\n\n\\code\n\nuint_t buffer_size = 1024;\n\n// create a vector of 512 values\nfvec_t * input = new_fvec (buffer_size);\n\n// set some values of the vector\ninput->data[23] = 2.;\n// ..\n\n// compute the mean of the vector\nmean = fvec_mean(a_vector);\n\n// destroy the vector\ndel_fvec(a_vector);\n\n\\endcode\n\nSee `examples/` and `tests/src` directories for more examples.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fvec_t {
    #[doc = "< length of buffer"]
    pub length: uint_t,
    #[doc = "< data vector of length ::fvec_t.length"]
    pub data: *mut smpl_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fvec_t"][::std::mem::size_of::<fvec_t>() - 16usize];
    ["Alignment of fvec_t"][::std::mem::align_of::<fvec_t>() - 8usize];
    ["Offset of field: fvec_t::length"][::std::mem::offset_of!(fvec_t, length) - 0usize];
    ["Offset of field: fvec_t::data"][::std::mem::offset_of!(fvec_t, data) - 8usize];
};
extern "C" {
    #[doc = " fvec_t buffer creation function\n\n\\param length the length of the buffer to create"]
    pub fn new_fvec(length: uint_t) -> *mut fvec_t;
}
extern "C" {
    #[doc = " fvec_t buffer deletion function\n\n\\param s buffer to delete as returned by new_fvec()"]
    pub fn del_fvec(s: *mut fvec_t);
}
extern "C" {
    #[doc = " read sample value in a buffer\n\n\\param s vector to read from\n\\param position sample position to read from"]
    pub fn fvec_get_sample(s: *const fvec_t, position: uint_t) -> smpl_t;
}
extern "C" {
    #[doc = " write sample value in a buffer\n\n\\param s vector to write to\n\\param data value to write in s->data[position]\n\\param position sample position to write to"]
    pub fn fvec_set_sample(s: *mut fvec_t, data: smpl_t, position: uint_t);
}
extern "C" {
    #[doc = " read data from a buffer\n\n\\param s vector to read from"]
    pub fn fvec_get_data(s: *const fvec_t) -> *mut smpl_t;
}
extern "C" {
    #[doc = " print out fvec data\n\n\\param s vector to print out"]
    pub fn fvec_print(s: *const fvec_t);
}
extern "C" {
    #[doc = " set all elements to a given value\n\n\\param s vector to modify\n\\param val value to set elements to"]
    pub fn fvec_set_all(s: *mut fvec_t, val: smpl_t);
}
extern "C" {
    #[doc = " set all elements to zero\n\n\\param s vector to modify"]
    pub fn fvec_zeros(s: *mut fvec_t);
}
extern "C" {
    #[doc = " set all elements to ones\n\n\\param s vector to modify"]
    pub fn fvec_ones(s: *mut fvec_t);
}
extern "C" {
    #[doc = " revert order of vector elements\n\n\\param s vector to revert"]
    pub fn fvec_rev(s: *mut fvec_t);
}
extern "C" {
    #[doc = " apply weight to vector\n\nIf the weight vector is longer than s, only the first elements are used. If\nthe weight vector is shorter than s, the last elements of s are not weighted.\n\n\\param s vector to weight\n\\param weight weighting coefficients"]
    pub fn fvec_weight(s: *mut fvec_t, weight: *const fvec_t);
}
extern "C" {
    #[doc = " make a copy of a vector\n\n\\param s source vector\n\\param t vector to copy to"]
    pub fn fvec_copy(s: *const fvec_t, t: *mut fvec_t);
}
extern "C" {
    #[doc = " make a copy of a vector, applying weights to each element\n\n\\param in input vector\n\\param weight weights vector\n\\param out output vector"]
    pub fn fvec_weighted_copy(in_: *const fvec_t, weight: *const fvec_t, out: *mut fvec_t);
}
#[doc = " Vector of real-valued phase and spectrum data\n\n\\code\n\nuint_t buffer_size = 1024;\n\n// create a complex vector of 512 values\ncvec_t * input = new_cvec (buffer_size);\n\n// set some values of the vector\ninput->norm[23] = 2.;\ninput->phas[23] = M_PI;\n// ..\n\n// compute the mean of the vector\nmean = cvec_mean(input);\n\n// destroy the vector\ndel_cvec (input);\n\n\\endcode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cvec_t {
    #[doc = "< length of buffer = (requested length)/2 + 1"]
    pub length: uint_t,
    #[doc = "< norm array of size ::cvec_t.length"]
    pub norm: *mut smpl_t,
    #[doc = "< phase array of size ::cvec_t.length"]
    pub phas: *mut smpl_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cvec_t"][::std::mem::size_of::<cvec_t>() - 24usize];
    ["Alignment of cvec_t"][::std::mem::align_of::<cvec_t>() - 8usize];
    ["Offset of field: cvec_t::length"][::std::mem::offset_of!(cvec_t, length) - 0usize];
    ["Offset of field: cvec_t::norm"][::std::mem::offset_of!(cvec_t, norm) - 8usize];
    ["Offset of field: cvec_t::phas"][::std::mem::offset_of!(cvec_t, phas) - 16usize];
};
extern "C" {
    #[doc = " cvec_t buffer creation function\n\nThis function creates a cvec_t structure holding two arrays of size\n[length/2+1], corresponding to the norm and phase values of the\nspectral frame. The length stored in the structure is the actual size of both\narrays, not the length of the complex and symmetrical vector, specified as\ncreation argument.\n\n\\param length the length of the buffer to create"]
    pub fn new_cvec(length: uint_t) -> *mut cvec_t;
}
extern "C" {
    #[doc = " cvec_t buffer deletion function\n\n\\param s buffer to delete as returned by new_cvec()"]
    pub fn del_cvec(s: *mut cvec_t);
}
extern "C" {
    #[doc = " write norm value in a complex buffer\n\nThis is equivalent to:\n\\code\ns->norm[position] = val;\n\\endcode\n\n\\param s vector to write to\n\\param val norm value to write in s->norm[position]\n\\param position sample position to write to"]
    pub fn cvec_norm_set_sample(s: *mut cvec_t, val: smpl_t, position: uint_t);
}
extern "C" {
    #[doc = " write phase value in a complex buffer\n\nThis is equivalent to:\n\\code\ns->phas[position] = val;\n\\endcode\n\n\\param s vector to write to\n\\param val phase value to write in s->phas[position]\n\\param position sample position to write to"]
    pub fn cvec_phas_set_sample(s: *mut cvec_t, val: smpl_t, position: uint_t);
}
extern "C" {
    #[doc = " read norm value from a complex buffer\n\nThis is equivalent to:\n\\code\nsmpl_t foo = s->norm[position];\n\\endcode\n\n\\param s vector to read from\n\\param position sample position to read from"]
    pub fn cvec_norm_get_sample(s: *mut cvec_t, position: uint_t) -> smpl_t;
}
extern "C" {
    #[doc = " read phase value from a complex buffer\n\nThis is equivalent to:\n\\code\nsmpl_t foo = s->phas[position];\n\\endcode\n\n\\param s vector to read from\n\\param position sample position to read from\n\\returns the value of the sample at position"]
    pub fn cvec_phas_get_sample(s: *mut cvec_t, position: uint_t) -> smpl_t;
}
extern "C" {
    #[doc = " read norm data from a complex buffer\n\n\\code\nsmpl_t *data = s->norm;\n\\endcode\n\n\\param s vector to read from"]
    pub fn cvec_norm_get_data(s: *const cvec_t) -> *mut smpl_t;
}
extern "C" {
    #[doc = " read phase data from a complex buffer\n\nThis is equivalent to:\n\\code\nsmpl_t *data = s->phas;\n\\endcode\n\n\\param s vector to read from"]
    pub fn cvec_phas_get_data(s: *const cvec_t) -> *mut smpl_t;
}
extern "C" {
    #[doc = " print out cvec data\n\n\\param s vector to print out"]
    pub fn cvec_print(s: *const cvec_t);
}
extern "C" {
    #[doc = " make a copy of a vector\n\n\\param s source vector\n\\param t vector to copy to"]
    pub fn cvec_copy(s: *const cvec_t, t: *mut cvec_t);
}
extern "C" {
    #[doc = " set all norm elements to a given value\n\n\\param s vector to modify\n\\param val value to set elements to"]
    pub fn cvec_norm_set_all(s: *mut cvec_t, val: smpl_t);
}
extern "C" {
    #[doc = " set all norm elements to zero\n\n\\param s vector to modify"]
    pub fn cvec_norm_zeros(s: *mut cvec_t);
}
extern "C" {
    #[doc = " set all norm elements to one\n\n\\param s vector to modify"]
    pub fn cvec_norm_ones(s: *mut cvec_t);
}
extern "C" {
    #[doc = " set all phase elements to a given value\n\n\\param s vector to modify\n\\param val value to set elements to"]
    pub fn cvec_phas_set_all(s: *mut cvec_t, val: smpl_t);
}
extern "C" {
    #[doc = " set all phase elements to zero\n\n\\param s vector to modify"]
    pub fn cvec_phas_zeros(s: *mut cvec_t);
}
extern "C" {
    #[doc = " set all phase elements to one\n\n\\param s vector to modify"]
    pub fn cvec_phas_ones(s: *mut cvec_t);
}
extern "C" {
    #[doc = " set all norm and phas elements to zero\n\n\\param s vector to modify"]
    pub fn cvec_zeros(s: *mut cvec_t);
}
extern "C" {
    #[doc = " take logarithmic magnitude\n\n\\param s input cvec to compress\n\\param lambda value to use for normalisation\n\n\\f$ S_k = log( \\lambda * S_k + 1 ) \\f$"]
    pub fn cvec_logmag(s: *mut cvec_t, lambda: smpl_t);
}
#[doc = " Buffer for real data in double precision"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lvec_t {
    #[doc = "< length of buffer"]
    pub length: uint_t,
    #[doc = "< data array of size [length]"]
    pub data: *mut lsmp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lvec_t"][::std::mem::size_of::<lvec_t>() - 16usize];
    ["Alignment of lvec_t"][::std::mem::align_of::<lvec_t>() - 8usize];
    ["Offset of field: lvec_t::length"][::std::mem::offset_of!(lvec_t, length) - 0usize];
    ["Offset of field: lvec_t::data"][::std::mem::offset_of!(lvec_t, data) - 8usize];
};
extern "C" {
    #[doc = " lvec_t buffer creation function\n\n\\param length the length of the buffer to create"]
    pub fn new_lvec(length: uint_t) -> *mut lvec_t;
}
extern "C" {
    #[doc = " lvec_t buffer deletion function\n\n\\param s buffer to delete as returned by new_lvec()"]
    pub fn del_lvec(s: *mut lvec_t);
}
extern "C" {
    #[doc = " read sample value in a buffer\n\n\\param s vector to read from\n\\param position sample position to read from"]
    pub fn lvec_get_sample(s: *mut lvec_t, position: uint_t) -> lsmp_t;
}
extern "C" {
    #[doc = " write sample value in a buffer\n\n\\param s vector to write to\n\\param data value to write in s->data[position]\n\\param position sample position to write to"]
    pub fn lvec_set_sample(s: *mut lvec_t, data: lsmp_t, position: uint_t);
}
extern "C" {
    #[doc = " read data from a buffer\n\n\\param s vector to read from"]
    pub fn lvec_get_data(s: *const lvec_t) -> *mut lsmp_t;
}
extern "C" {
    #[doc = " print out lvec data\n\n\\param s vector to print out"]
    pub fn lvec_print(s: *const lvec_t);
}
extern "C" {
    #[doc = " set all elements to a given value\n\n\\param s vector to modify\n\\param val value to set elements to"]
    pub fn lvec_set_all(s: *mut lvec_t, val: smpl_t);
}
extern "C" {
    #[doc = " set all elements to zero\n\n\\param s vector to modify"]
    pub fn lvec_zeros(s: *mut lvec_t);
}
extern "C" {
    #[doc = " set all elements to ones\n\n\\param s vector to modify"]
    pub fn lvec_ones(s: *mut lvec_t);
}
#[doc = " Buffer for real data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fmat_t {
    #[doc = "< length of matrix"]
    pub length: uint_t,
    #[doc = "< height of matrix"]
    pub height: uint_t,
    #[doc = "< data array of size [length] * [height]"]
    pub data: *mut *mut smpl_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fmat_t"][::std::mem::size_of::<fmat_t>() - 16usize];
    ["Alignment of fmat_t"][::std::mem::align_of::<fmat_t>() - 8usize];
    ["Offset of field: fmat_t::length"][::std::mem::offset_of!(fmat_t, length) - 0usize];
    ["Offset of field: fmat_t::height"][::std::mem::offset_of!(fmat_t, height) - 4usize];
    ["Offset of field: fmat_t::data"][::std::mem::offset_of!(fmat_t, data) - 8usize];
};
extern "C" {
    #[doc = " fmat_t buffer creation function\n\n\\param length the length of the matrix to create\n\\param height the height of the matrix to create"]
    pub fn new_fmat(height: uint_t, length: uint_t) -> *mut fmat_t;
}
extern "C" {
    #[doc = " fmat_t buffer deletion function\n\n\\param s buffer to delete as returned by new_fmat()"]
    pub fn del_fmat(s: *mut fmat_t);
}
extern "C" {
    #[doc = " read sample value in a buffer\n\n\\param s vector to read from\n\\param channel channel to read from\n\\param position sample position to read from"]
    pub fn fmat_get_sample(s: *const fmat_t, channel: uint_t, position: uint_t) -> smpl_t;
}
extern "C" {
    #[doc = " write sample value in a buffer\n\n\\param s vector to write to\n\\param data value to write in s->data[channel][position]\n\\param channel channel to write to\n\\param position sample position to write to"]
    pub fn fmat_set_sample(s: *mut fmat_t, data: smpl_t, channel: uint_t, position: uint_t);
}
extern "C" {
    #[doc = " read channel vector from a buffer\n\n\\param s vector to read from\n\\param channel channel to read from\n\\param output ::fvec_t to output to"]
    pub fn fmat_get_channel(s: *const fmat_t, channel: uint_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " get vector buffer from an fmat data\n\n\\param s vector to read from\n\\param channel channel to read from"]
    pub fn fmat_get_channel_data(s: *const fmat_t, channel: uint_t) -> *mut smpl_t;
}
extern "C" {
    #[doc = " read data from a buffer\n\n\\param s vector to read from"]
    pub fn fmat_get_data(s: *const fmat_t) -> *mut *mut smpl_t;
}
extern "C" {
    #[doc = " print out fmat data\n\n\\param s vector to print out"]
    pub fn fmat_print(s: *const fmat_t);
}
extern "C" {
    #[doc = " set all elements to a given value\n\n\\param s vector to modify\n\\param val value to set elements to"]
    pub fn fmat_set(s: *mut fmat_t, val: smpl_t);
}
extern "C" {
    #[doc = " set all elements to zero\n\n\\param s vector to modify"]
    pub fn fmat_zeros(s: *mut fmat_t);
}
extern "C" {
    #[doc = " set all elements to ones\n\n\\param s vector to modify"]
    pub fn fmat_ones(s: *mut fmat_t);
}
extern "C" {
    #[doc = " revert order of vector elements\n\n\\param s vector to revert"]
    pub fn fmat_rev(s: *mut fmat_t);
}
extern "C" {
    #[doc = " apply weight to vector\n\nIf the weight vector is longer than s, only the first elements are used. If\nthe weight vector is shorter than s, the last elements of s are not weighted.\n\n\\param s vector to weight\n\\param weight weighting coefficients"]
    pub fn fmat_weight(s: *mut fmat_t, weight: *const fmat_t);
}
extern "C" {
    #[doc = " make a copy of a matrix\n\n\\param s source vector\n\\param t vector to copy to"]
    pub fn fmat_copy(s: *const fmat_t, t: *mut fmat_t);
}
extern "C" {
    #[doc = " compute the product of a matrix by a vector\n\n\\param s matrix to compute product with\n\\param scale vector to compute product with\n\\param output vector to store restults in"]
    pub fn fmat_vecmul(s: *const fmat_t, scale: *const fvec_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " create window\n\n\\param window_type type of the window to create\n\\param size length of the window to create (see fvec_set_window())"]
    pub fn new_aubio_window(window_type: *mut char_t, size: uint_t) -> *mut fvec_t;
}
extern "C" {
    #[doc = " set elements of a vector to window coefficients\n\n\\param window exsting ::fvec_t to use\n\\param window_type type of the window to create\n\nList of available window types: \"rectangle\", \"hamming\", \"hanning\",\n\"hanningz\", \"blackman\", \"blackman_harris\", \"gaussian\", \"welch\", \"parzen\",\n\"default\".\n\n\"default\" is equivalent to \"hanningz\".\n\nReferences:\n\n- <a href=\"http://en.wikipedia.org/wiki/Window_function\">Window\nfunction</a> on Wikipedia\n- Amalia de Götzen, Nicolas Bernardini, and Daniel Arfib. Traditional (?)\nimplementations of a phase vocoder: the tricks of the trade. In Proceedings of\nthe International Conference on Digital Audio Effects (DAFx-00), pages 37–44,\nUni- versity of Verona, Italy, 2000.\n(<a href=\"http://www.cs.princeton.edu/courses/archive/spr09/cos325/Bernardini.pdf\">\npdf</a>)\n"]
    pub fn fvec_set_window(window: *mut fvec_t, window_type: *mut char_t) -> uint_t;
}
extern "C" {
    #[doc = " compute the principal argument\n\nThis function maps the input phase to its corresponding value wrapped in the\nrange \\f$ [-\\pi, \\pi] \\f$.\n\n\\param phase unwrapped phase to map to the unit circle\n\n\\return equivalent phase wrapped to the unit circle"]
    pub fn aubio_unwrap2pi(phase: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert frequency bin to midi value"]
    pub fn aubio_bintomidi(bin: smpl_t, samplerate: smpl_t, fftsize: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert midi value to frequency bin"]
    pub fn aubio_miditobin(midi: smpl_t, samplerate: smpl_t, fftsize: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert frequency bin to frequency (Hz)"]
    pub fn aubio_bintofreq(bin: smpl_t, samplerate: smpl_t, fftsize: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert frequency (Hz) to frequency bin"]
    pub fn aubio_freqtobin(freq: smpl_t, samplerate: smpl_t, fftsize: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert frequency (Hz) to mel\n\n\\param freq input frequency, in Hz\n\n\\return output mel\n\nConverts a scalar from the frequency domain to the mel scale using Slaney\nAuditory Toolbox's implementation:\n\nIf \\f$ f < 1000 \\f$, \\f$ m = 3 f / 200 \\f$.\n\nIf \\f$ f >= 1000 \\f$, \\f$ m = 1000 + 27 \\frac{{ln}(f) - ln(1000))}\n{{ln}(6400) - ln(1000)}\n\\f$\n\nSee also\n--------\n\naubio_meltohz(), aubio_hztomel_htk()."]
    pub fn aubio_hztomel(freq: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert mel to frequency (Hz)\n\n\\param mel input mel\n\n\\return output frequency, in Hz\n\nConverts a scalar from the mel scale to the frequency domain using Slaney\nAuditory Toolbox's implementation:\n\nIf \\f$ f < 1000 \\f$, \\f$ f = 200 m/3 \\f$.\n\nIf \\f$ f \\geq 1000 \\f$, \\f$ f = 1000 + \\left(\\frac{6400}{1000}\\right)\n^{\\frac{m - 1000}{27}} \\f$\n\nSee also\n--------\n\naubio_hztomel(), aubio_meltohz_htk().\n\nReferences\n----------\n\nMalcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*\nhttps://engineering.purdue.edu/~malcolm/interval/1998-010/"]
    pub fn aubio_meltohz(mel: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert frequency (Hz) to mel\n\n\\param freq input frequency, in Hz\n\n\\return output mel\n\nConverts a scalar from the frequency domain to the mel scale, using the\nequation defined by O'Shaughnessy, as implemented in the HTK speech\nrecognition toolkit:\n\n\\f$ m = 1127 + ln(1 + \\frac{f}{700}) \\f$\n\nSee also\n--------\n\naubio_meltohz_htk(), aubio_hztomel().\n\nReferences\n----------\n\nDouglas O'Shaughnessy (1987). *Speech communication: human and machine*.\nAddison-Wesley. p. 150. ISBN 978-0-201-16520-3.\n\nHTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/\n"]
    pub fn aubio_hztomel_htk(freq: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert mel to frequency (Hz)\n\n\\param mel input mel\n\n\\return output frequency, in Hz\n\nConverts a scalar from the mel scale to the frequency domain, using the\nequation defined by O'Shaughnessy, as implemented in the HTK speech\nrecognition toolkit:\n\n\\f$ f = 700 * {e}^\\left(\\frac{f}{1127} - 1\\right) \\f$\n\nSee also\n--------\n\naubio_hztomel_htk(), aubio_meltohz()."]
    pub fn aubio_meltohz_htk(mel: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert frequency (Hz) to midi value (0-128)"]
    pub fn aubio_freqtomidi(freq: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " convert midi value (0-128) to frequency (Hz)"]
    pub fn aubio_miditofreq(midi: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " clean up cached memory at the end of program\n\nThis function should be used at the end of programs to purge all cached\nmemory. So far it is only useful to clean FFTW's cache."]
    pub fn aubio_cleanup();
}
extern "C" {
    #[doc = " zero-crossing rate (ZCR)\n\nThe zero-crossing rate is the number of times a signal changes sign,\ndivided by the length of this signal.\n\n\\param v vector to compute ZCR from\n\n\\return zero-crossing rate of v"]
    pub fn aubio_zero_crossing_rate(v: *mut fvec_t) -> smpl_t;
}
extern "C" {
    #[doc = " compute sound level on a linear scale\n\nThis gives the average of the square amplitudes.\n\n\\param v vector to compute level from\n\n\\return level of v"]
    pub fn aubio_level_lin(v: *const fvec_t) -> smpl_t;
}
extern "C" {
    #[doc = " compute sound pressure level (SPL) in dB\n\nThis quantity is often wrongly called 'loudness'.\n\nThis gives ten times the log10 of the average of the square amplitudes.\n\n\\param v vector to compute dB SPL from\n\n\\return level of v in dB SPL"]
    pub fn aubio_db_spl(v: *const fvec_t) -> smpl_t;
}
extern "C" {
    #[doc = " check if buffer level in dB SPL is under a given threshold\n\n\\param v vector to get level from\n\\param threshold threshold in dB SPL\n\n\\return 0 if level is under the given threshold, 1 otherwise"]
    pub fn aubio_silence_detection(v: *const fvec_t, threshold: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get buffer level if level >= threshold, 1. otherwise\n\n\\param v vector to get level from\n\\param threshold threshold in dB SPL\n\n\\return level in dB SPL if level >= threshold, 1. otherwise"]
    pub fn aubio_level_detection(v: *const fvec_t, threshold: smpl_t) -> smpl_t;
}
extern "C" {
    #[doc = " clamp the values of a vector within the range [-abs(max), abs(max)]\n\n\\param in vector to clamp\n\\param absmax maximum value over which input vector elements should be clamped"]
    pub fn fvec_clamp(in_: *mut fvec_t, absmax: smpl_t);
}
extern "C" {
    #[doc = " compute \\f$e^x\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_exp(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute \\f$cos(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_cos(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute \\f$sin(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_sin(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$abs(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_abs(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$sqrt(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_sqrt(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$log10(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_log10(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$log(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_log(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$floor(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_floor(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$ceil(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_ceil(s: *mut fvec_t);
}
extern "C" {
    #[doc = " compute the \\f$round(x)\\f$ of each vector elements\n\n\\param s vector to modify"]
    pub fn fvec_round(s: *mut fvec_t);
}
extern "C" {
    #[doc = " raise each vector elements to the power pow\n\n\\param s vector to modify\n\\param pow power to raise to"]
    pub fn fvec_pow(s: *mut fvec_t, pow: smpl_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_resampler_t {
    _unused: [u8; 0],
}
#[doc = " resampler object"]
pub type aubio_resampler_t = _aubio_resampler_t;
extern "C" {
    #[doc = " create resampler object\n\n\\param ratio output_sample_rate / input_sample_rate\n\\param type libsamplerate resampling type, see http://www.mega-nerd.com/SRC/api_misc.html#Converters"]
    pub fn new_aubio_resampler(ratio: smpl_t, type_: uint_t) -> *mut aubio_resampler_t;
}
extern "C" {
    #[doc = " delete resampler object"]
    pub fn del_aubio_resampler(s: *mut aubio_resampler_t);
}
extern "C" {
    #[doc = " resample input in output\n\n\\param s resampler object\n\\param input input buffer of size N\n\\param output output buffer of size N*ratio"]
    pub fn aubio_resampler_do(s: *mut aubio_resampler_t, input: *const fvec_t, output: *mut fvec_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_filter_t {
    _unused: [u8; 0],
}
#[doc = " Digital filter"]
pub type aubio_filter_t = _aubio_filter_t;
extern "C" {
    #[doc = " filter input vector (in-place)\n\n\\param f filter object as returned by new_aubio_filter()\n\\param in input vector to filter"]
    pub fn aubio_filter_do(f: *mut aubio_filter_t, in_: *mut fvec_t);
}
extern "C" {
    #[doc = " filter input vector (out-of-place)\n\n\\param f filter object as returned by new_aubio_filter()\n\\param in input vector to filter\n\\param out output vector to store filtered input"]
    pub fn aubio_filter_do_outplace(f: *mut aubio_filter_t, in_: *const fvec_t, out: *mut fvec_t);
}
extern "C" {
    #[doc = " filter input vector forward and backward\n\n\\param f ::aubio_filter_t object as returned by new_aubio_filter()\n\\param in ::fvec_t input vector to filter\n\\param tmp memory space to use for computation"]
    pub fn aubio_filter_do_filtfilt(f: *mut aubio_filter_t, in_: *mut fvec_t, tmp: *mut fvec_t);
}
extern "C" {
    #[doc = " returns a pointer to feedback coefficients \\f$ a_i \\f$\n\n\\param f filter object to get parameters from\n\n\\return a pointer to the \\f$ a_0 ... a_i ... a_P \\f$ coefficients"]
    pub fn aubio_filter_get_feedback(f: *const aubio_filter_t) -> *mut lvec_t;
}
extern "C" {
    #[doc = " returns a pointer to feedforward coefficients \\f$ b_i \\f$\n\n\\param f filter object to get coefficients from\n\n\\return a pointer to the \\f$ b_0 ... b_i ... b_P \\f$ coefficients"]
    pub fn aubio_filter_get_feedforward(f: *const aubio_filter_t) -> *mut lvec_t;
}
extern "C" {
    #[doc = " get order of the filter\n\n\\param f filter to get order from\n\n\\return the order of the filter"]
    pub fn aubio_filter_get_order(f: *const aubio_filter_t) -> uint_t;
}
extern "C" {
    #[doc = " get sampling rate of the filter\n\n\\param f filter to get sampling rate from\n\n\\return the sampling rate of the filter, in Hz"]
    pub fn aubio_filter_get_samplerate(f: *const aubio_filter_t) -> uint_t;
}
extern "C" {
    #[doc = " get sampling rate of the filter\n\n\\param f filter to get sampling rate from\n\\param samplerate sample rate to set the filter to\n\n\\return the sampling rate of the filter, in Hz"]
    pub fn aubio_filter_set_samplerate(f: *mut aubio_filter_t, samplerate: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " reset filter memory\n\n\\param f filter object as returned by new_aubio_filter()"]
    pub fn aubio_filter_do_reset(f: *mut aubio_filter_t);
}
extern "C" {
    #[doc = " create new filter object\n\nThis function creates a new ::aubio_filter_t object, given the order of the\nfilter.\n\n\\param order order of the filter (number of coefficients)\n\n\\return the newly created filter object"]
    pub fn new_aubio_filter(order: uint_t) -> *mut aubio_filter_t;
}
extern "C" {
    #[doc = " delete a filter object\n\n\\param f filter object to delete"]
    pub fn del_aubio_filter(f: *mut aubio_filter_t);
}
extern "C" {
    #[doc = " set coefficients of a biquad filter\n\n\\param f filter object as returned by new_aubio_filter()\n\\param b0 forward filter coefficient\n\\param b1 forward filter coefficient\n\\param b2 forward filter coefficient\n\\param a1 feedback filter coefficient\n\\param a2 feedback filter coefficient"]
    pub fn aubio_filter_set_biquad(
        f: *mut aubio_filter_t,
        b0: lsmp_t,
        b1: lsmp_t,
        b2: lsmp_t,
        a1: lsmp_t,
        a2: lsmp_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " create biquad filter with `b0`, `b1`, `b2`, `a1`, `a2` coeffs\n\n\\param b0 forward filter coefficient\n\\param b1 forward filter coefficient\n\\param b2 forward filter coefficient\n\\param a1 feedback filter coefficient\n\\param a2 feedback filter coefficient"]
    pub fn new_aubio_filter_biquad(
        b0: lsmp_t,
        b1: lsmp_t,
        b2: lsmp_t,
        a1: lsmp_t,
        a2: lsmp_t,
    ) -> *mut aubio_filter_t;
}
extern "C" {
    #[doc = " create new A-design filter\n\n\\param samplerate sampling frequency of the signal to filter. Should be one of\n8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and\n192000 Hz\n\n\\return a new filter object"]
    pub fn new_aubio_filter_a_weighting(samplerate: uint_t) -> *mut aubio_filter_t;
}
extern "C" {
    #[doc = " set feedback and feedforward coefficients of a A-weighting filter\n\n\\param f filter object to get coefficients from\n\\param samplerate sampling frequency of the signal to filter. Should be one of\n8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and\n192000 Hz"]
    pub fn aubio_filter_set_a_weighting(f: *mut aubio_filter_t, samplerate: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " create new C-design filter\n\n\\param samplerate sampling frequency of the signal to filter. Should be one of\n8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and\n192000 Hz\n\n\\return a new filter object"]
    pub fn new_aubio_filter_c_weighting(samplerate: uint_t) -> *mut aubio_filter_t;
}
extern "C" {
    #[doc = " set feedback and feedforward coefficients of a C-weighting filter\n\n\\param f filter object to get coefficients from\n\\param samplerate sampling frequency of the signal to filter. Should be one of\n8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, and\n192000 Hz"]
    pub fn aubio_filter_set_c_weighting(f: *mut aubio_filter_t, samplerate: uint_t) -> uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_fft_t {
    _unused: [u8; 0],
}
#[doc = " FFT object\n\nThis object computes forward and backward FFTs."]
pub type aubio_fft_t = _aubio_fft_t;
extern "C" {
    #[doc = " create new FFT computation object\n\n\\param size length of the FFT"]
    pub fn new_aubio_fft(size: uint_t) -> *mut aubio_fft_t;
}
extern "C" {
    #[doc = " delete FFT object\n\n\\param s fft object as returned by new_aubio_fft"]
    pub fn del_aubio_fft(s: *mut aubio_fft_t);
}
extern "C" {
    #[doc = " compute forward FFT\n\n\\param s fft object as returned by new_aubio_fft\n\\param input input signal\n\\param spectrum output spectrum"]
    pub fn aubio_fft_do(s: *mut aubio_fft_t, input: *const fvec_t, spectrum: *mut cvec_t);
}
extern "C" {
    #[doc = " compute backward (inverse) FFT\n\n\\param s fft object as returned by new_aubio_fft\n\\param spectrum input spectrum\n\\param output output signal"]
    pub fn aubio_fft_rdo(s: *mut aubio_fft_t, spectrum: *const cvec_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " compute forward FFT\n\n\\param s fft object as returned by new_aubio_fft\n\\param input real input signal\n\\param compspec complex output fft real/imag"]
    pub fn aubio_fft_do_complex(s: *mut aubio_fft_t, input: *const fvec_t, compspec: *mut fvec_t);
}
extern "C" {
    #[doc = " compute backward (inverse) FFT from real/imag\n\n\\param s fft object as returned by new_aubio_fft\n\\param compspec real/imag input fft array\n\\param output real output array"]
    pub fn aubio_fft_rdo_complex(s: *mut aubio_fft_t, compspec: *const fvec_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " convert real/imag spectrum to norm/phas spectrum\n\n\\param compspec real/imag input fft array\n\\param spectrum cvec norm/phas output array"]
    pub fn aubio_fft_get_spectrum(compspec: *const fvec_t, spectrum: *mut cvec_t);
}
extern "C" {
    #[doc = " convert real/imag spectrum to norm/phas spectrum\n\n\\param compspec real/imag input fft array\n\\param spectrum cvec norm/phas output array"]
    pub fn aubio_fft_get_realimag(spectrum: *const cvec_t, compspec: *mut fvec_t);
}
extern "C" {
    #[doc = " compute phas spectrum from real/imag parts\n\n\\param compspec real/imag input fft array\n\\param spectrum cvec norm/phas output array"]
    pub fn aubio_fft_get_phas(compspec: *const fvec_t, spectrum: *mut cvec_t);
}
extern "C" {
    #[doc = " compute imaginary part from the norm/phas cvec\n\n\\param spectrum norm/phas input array\n\\param compspec real/imag output fft array"]
    pub fn aubio_fft_get_imag(spectrum: *const cvec_t, compspec: *mut fvec_t);
}
extern "C" {
    #[doc = " compute norm component from real/imag parts\n\n\\param compspec real/imag input fft array\n\\param spectrum cvec norm/phas output array"]
    pub fn aubio_fft_get_norm(compspec: *const fvec_t, spectrum: *mut cvec_t);
}
extern "C" {
    #[doc = " compute real part from norm/phas components\n\n\\param spectrum norm/phas input array\n\\param compspec real/imag output fft array"]
    pub fn aubio_fft_get_real(spectrum: *const cvec_t, compspec: *mut fvec_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_dct_t {
    _unused: [u8; 0],
}
#[doc = " DCT object\n\nThis object computes forward and backward DCT type 2 with orthonormal\nscaling."]
pub type aubio_dct_t = _aubio_dct_t;
extern "C" {
    #[doc = " create new DCT computation object\n\n\\param size length of the DCT"]
    pub fn new_aubio_dct(size: uint_t) -> *mut aubio_dct_t;
}
extern "C" {
    #[doc = " compute forward DCT\n\n\\param s dct object as returned by new_aubio_dct\n\\param input input signal\n\\param dct_output transformed input array"]
    pub fn aubio_dct_do(s: *mut aubio_dct_t, input: *const fvec_t, dct_output: *mut fvec_t);
}
extern "C" {
    #[doc = " compute backward DCT\n\n\\param s dct object as returned by new_aubio_dct\n\\param input input signal\n\\param idct_output transformed input array"]
    pub fn aubio_dct_rdo(s: *mut aubio_dct_t, input: *const fvec_t, idct_output: *mut fvec_t);
}
extern "C" {
    #[doc = " delete DCT object\n\n\\param s dct object as returned by new_aubio_dct"]
    pub fn del_aubio_dct(s: *mut aubio_dct_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_pvoc_t {
    _unused: [u8; 0],
}
#[doc = " phasevocoder object"]
pub type aubio_pvoc_t = _aubio_pvoc_t;
extern "C" {
    #[doc = " create phase vocoder object\n\n\\param win_s size of analysis buffer (and length the FFT transform)\n\\param hop_s step size between two consecutive analysis"]
    pub fn new_aubio_pvoc(win_s: uint_t, hop_s: uint_t) -> *mut aubio_pvoc_t;
}
extern "C" {
    #[doc = " delete phase vocoder object\n\n\\param pv phase vocoder object as returned by new_aubio_pvoc"]
    pub fn del_aubio_pvoc(pv: *mut aubio_pvoc_t);
}
extern "C" {
    #[doc = " compute spectral frame\n\nThis function accepts an input vector of size [hop_s]. The\nanalysis buffer is rotated and filled with the new data. After windowing of\nthis signal window, the Fourier transform is computed and returned in\nfftgrain as two vectors, magnitude and phase.\n\n\\param pv phase vocoder object as returned by new_aubio_pvoc\n\\param in new input signal (hop_s long)\n\\param fftgrain output spectral frame"]
    pub fn aubio_pvoc_do(pv: *mut aubio_pvoc_t, in_: *const fvec_t, fftgrain: *mut cvec_t);
}
extern "C" {
    #[doc = " compute signal from spectral frame\n\nThis function takes an input spectral frame fftgrain of size\n[buf_s] and computes its inverse Fourier transform. Overlap-add\nsynthesis is then computed using the previously synthetised frames, and the\noutput stored in out.\n\n\\param pv phase vocoder object as returned by new_aubio_pvoc\n\\param fftgrain input spectral frame\n\\param out output signal (hop_s long)"]
    pub fn aubio_pvoc_rdo(pv: *mut aubio_pvoc_t, fftgrain: *mut cvec_t, out: *mut fvec_t);
}
extern "C" {
    #[doc = " get window size\n\n\\param pv phase vocoder to get the window size from"]
    pub fn aubio_pvoc_get_win(pv: *mut aubio_pvoc_t) -> uint_t;
}
extern "C" {
    #[doc = " get hop size\n\n\\param pv phase vocoder to get the hop size from"]
    pub fn aubio_pvoc_get_hop(pv: *mut aubio_pvoc_t) -> uint_t;
}
extern "C" {
    #[doc = " set window type\n\n\\param pv phase vocoder to set the window type\n\\param window_type a string representing a window\n\n\\return 0 if successful, non-zero otherwise\n"]
    pub fn aubio_pvoc_set_window(pv: *mut aubio_pvoc_t, window_type: *const char_t) -> uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_filterbank_t {
    _unused: [u8; 0],
}
#[doc = " filterbank object\n\nThis object stores a matrix of spectral filter coefficients.\n"]
pub type aubio_filterbank_t = _aubio_filterbank_t;
extern "C" {
    #[doc = " create filterbank object\n\n\\param n_filters number of filters to create\n\\param win_s size of analysis buffer (and length the FFT transform)"]
    pub fn new_aubio_filterbank(n_filters: uint_t, win_s: uint_t) -> *mut aubio_filterbank_t;
}
extern "C" {
    #[doc = " destroy filterbank object\n\n\\param f filterbank object, as returned by new_aubio_filterbank()"]
    pub fn del_aubio_filterbank(f: *mut aubio_filterbank_t);
}
extern "C" {
    #[doc = " compute filterbank\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n\\param in input spectrum containing an input spectrum of length `win_s`\n\\param out output vector containing the energy found in each band, `nfilt` output values"]
    pub fn aubio_filterbank_do(f: *mut aubio_filterbank_t, in_: *const cvec_t, out: *mut fvec_t);
}
extern "C" {
    #[doc = " return a pointer to the matrix object containing all filter coefficients\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n"]
    pub fn aubio_filterbank_get_coeffs(f: *const aubio_filterbank_t) -> *mut fmat_t;
}
extern "C" {
    #[doc = " copy filter coefficients to the filterbank\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n\\param filters filter bank coefficients to copy from\n"]
    pub fn aubio_filterbank_set_coeffs(
        f: *mut aubio_filterbank_t,
        filters: *const fmat_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " set norm parameter\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n\\param norm `1` to norm the filters, `0` otherwise.\n\nIf set to `0`, the filters will not be normalized. If set to `1`,\neach filter will be normalized to one. Defaults to `1`.\n\nThis function should be called *before* setting the filters with one of\naubio_filterbank_set_triangle_bands(), aubio_filterbank_set_mel_coeffs(),\naubio_filterbank_set_mel_coeffs_htk(), or\naubio_filterbank_set_mel_coeffs_slaney().\n"]
    pub fn aubio_filterbank_set_norm(f: *mut aubio_filterbank_t, norm: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get norm parameter\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n\\returns `1` if norm is set, `0` otherwise. Defaults to `1`.\n"]
    pub fn aubio_filterbank_get_norm(f: *mut aubio_filterbank_t) -> smpl_t;
}
extern "C" {
    #[doc = " set power parameter\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n\\param power Raise norm of the input spectrum norm to this power before\ncomputing filterbank.  Defaults to `1`.\n"]
    pub fn aubio_filterbank_set_power(f: *mut aubio_filterbank_t, power: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get power parameter\n\n\\param f filterbank object, as returned by new_aubio_filterbank()\n\\return current power parameter. Defaults to `1`.\n"]
    pub fn aubio_filterbank_get_power(f: *mut aubio_filterbank_t) -> smpl_t;
}
extern "C" {
    #[doc = " filterbank initialization with triangular and overlapping bands\n\n\\param fb filterbank object\n\\param freqs arbitrary array of boundary frequencies\n\\param samplerate audio sampling rate\n\nThis function computes the coefficients of the filterbank based on the\nboundaries found in freqs, in Hz, and using triangular overlapping bands."]
    pub fn aubio_filterbank_set_triangle_bands(
        fb: *mut aubio_filterbank_t,
        freqs: *const fvec_t,
        samplerate: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " filterbank initialization for Mel filters using Slaney's coefficients\n\n\\param fb filterbank object\n\\param samplerate audio sampling rate, in Hz\n\nThe filter coefficients are built to match exactly Malcolm Slaney's Auditory\nToolbox implementation (see file mfcc.m). The number of filters should be 40.\n\nReferences\n----------\n\nMalcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*\nhttps://engineering.purdue.edu/~malcolm/interval/1998-010/"]
    pub fn aubio_filterbank_set_mel_coeffs_slaney(
        fb: *mut aubio_filterbank_t,
        samplerate: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " Mel filterbank initialization\n\n\\param fb filterbank object\n\\param samplerate audio sampling rate\n\\param fmin start frequency, in Hz\n\\param fmax end frequency, in Hz\n\nThe filterbank will be initialized with bands linearly spaced in the mel\nscale, from `fmin` to `fmax`.\n\nReferences\n----------\n\nMalcolm Slaney, *Auditory Toolbox Version 2, Technical Report #1998-010*\nhttps://engineering.purdue.edu/~malcolm/interval/1998-010/"]
    pub fn aubio_filterbank_set_mel_coeffs(
        fb: *mut aubio_filterbank_t,
        samplerate: smpl_t,
        fmin: smpl_t,
        fmax: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " Mel filterbank initialization\n\n\\param fb filterbank object\n\\param samplerate audio sampling rate\n\\param fmin start frequency, in Hz\n\\param fmax end frequency, in Hz\n\nThe bank of filters will be initalized to to cover linearly spaced bands in\nthe Htk mel scale, from `fmin` to `fmax`.\n\nReferences\n----------\n\nDouglas O'Shaughnessy (1987). *Speech communication: human and machine*.\nAddison-Wesley. p. 150. ISBN 978-0-201-16520-3.\n\nHTK Speech Recognition Toolkit: http://htk.eng.cam.ac.uk/"]
    pub fn aubio_filterbank_set_mel_coeffs_htk(
        fb: *mut aubio_filterbank_t,
        samplerate: smpl_t,
        fmin: smpl_t,
        fmax: smpl_t,
    ) -> uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_mfcc_t {
    _unused: [u8; 0],
}
#[doc = " mfcc object"]
pub type aubio_mfcc_t = _aubio_mfcc_t;
extern "C" {
    #[doc = " create mfcc object\n\n\\param buf_size size of analysis buffer (and length the FFT transform)\n\\param samplerate audio sampling rate\n\\param n_coeffs number of desired coefficients\n\\param n_filters number of desired filters"]
    pub fn new_aubio_mfcc(
        buf_size: uint_t,
        n_filters: uint_t,
        n_coeffs: uint_t,
        samplerate: uint_t,
    ) -> *mut aubio_mfcc_t;
}
extern "C" {
    #[doc = " delete mfcc object\n\n\\param mf mfcc object as returned by new_aubio_mfcc"]
    pub fn del_aubio_mfcc(mf: *mut aubio_mfcc_t);
}
extern "C" {
    #[doc = " mfcc object processing\n\n\\param mf mfcc object as returned by new_aubio_mfcc\n\\param in input spectrum (buf_size long)\n\\param out output mel coefficients buffer (n_coeffs long)"]
    pub fn aubio_mfcc_do(mf: *mut aubio_mfcc_t, in_: *const cvec_t, out: *mut fvec_t);
}
extern "C" {
    #[doc = " set power parameter\n\n\\param mf mfcc object, as returned by new_aubio_mfcc()\n\\param power Raise norm of the input spectrum norm to this power before\ncomputing filterbank.  Defaults to `1`.\n\nSee aubio_filterbank_set_power().\n"]
    pub fn aubio_mfcc_set_power(mf: *mut aubio_mfcc_t, power: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get power parameter\n\n\\param mf mfcc object, as returned by new_aubio_mfcc()\n\\return current power parameter. Defaults to `1`.\n\nSee aubio_filterbank_get_power().\n"]
    pub fn aubio_mfcc_get_power(mf: *mut aubio_mfcc_t) -> smpl_t;
}
extern "C" {
    #[doc = " set scaling parameter\n\n\\param mf mfcc object, as returned by new_aubio_mfcc()\n\\param scale Scaling value to apply.\n\nScales the output of the filterbank after taking its logarithm and before\ncomputing the DCT. Defaults to `1`."]
    pub fn aubio_mfcc_set_scale(mf: *mut aubio_mfcc_t, scale: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get scaling parameter\n\n\\param mf mfcc object, as returned by new_aubio_mfcc()\n\\return current scaling parameter. Defaults to `1`.\n"]
    pub fn aubio_mfcc_get_scale(mf: *mut aubio_mfcc_t) -> smpl_t;
}
extern "C" {
    #[doc = " Mel filterbank initialization\n\n\\param mf mfcc object\n\\param fmin start frequency, in Hz\n\\param fmax end frequency, in Hz\n\nThe filterbank will be initialized with bands linearly spaced in the mel\nscale, from `fmin` to `fmax`.\n\nSee also\n--------\n\naubio_filterbank_set_mel_coeffs()"]
    pub fn aubio_mfcc_set_mel_coeffs(mf: *mut aubio_mfcc_t, fmin: smpl_t, fmax: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " Mel filterbank initialization\n\n\\param mf mfcc object\n\\param fmin start frequency, in Hz\n\\param fmax end frequency, in Hz\n\nThe bank of filters will be initalized to to cover linearly spaced bands in\nthe Htk mel scale, from `fmin` to `fmax`.\n\nSee also\n--------\n\naubio_filterbank_set_mel_coeffs_htk()"]
    pub fn aubio_mfcc_set_mel_coeffs_htk(
        mf: *mut aubio_mfcc_t,
        fmin: smpl_t,
        fmax: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " Mel filterbank initialization (Auditory Toolbox's parameters)\n\n\\param mf mfcc object\n\nThe filter coefficients are built to match exactly Malcolm Slaney's Auditory\nToolbox implementation. The number of filters should be 40.\n\nThis is the default filterbank when `mf` was created with `n_filters = 40`.\n\nSee also\n--------\n\naubio_filterbank_set_mel_coeffs_slaney()"]
    pub fn aubio_mfcc_set_mel_coeffs_slaney(mf: *mut aubio_mfcc_t) -> uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_specdesc_t {
    _unused: [u8; 0],
}
#[doc = " spectral description structure"]
pub type aubio_specdesc_t = _aubio_specdesc_t;
extern "C" {
    #[doc = " execute spectral description function on a spectral frame\n\nGeneric function to compute spectral description.\n\n\\param o spectral description object as returned by new_aubio_specdesc()\n\\param fftgrain input signal spectrum as computed by aubio_pvoc_do\n\\param desc output vector (one sample long, to send to the peak picking)"]
    pub fn aubio_specdesc_do(o: *mut aubio_specdesc_t, fftgrain: *const cvec_t, desc: *mut fvec_t);
}
extern "C" {
    #[doc = " creation of a spectral description object\n\n\\param method spectral description method\n\\param buf_size length of the input spectrum frame\n\nThe parameter \\p method is a string that can be any of:\n\n- onset novelty functions: `complex`, `energy`, `hfc`, `kl`, `mkl`,\n`phase`, `specdiff`, `specflux`, `wphase`,\n\n- spectral descriptors: `centroid`, `decrease`, `kurtosis`, `rolloff`,\n`skewness`, `slope`, `spread`."]
    pub fn new_aubio_specdesc(method: *const char_t, buf_size: uint_t) -> *mut aubio_specdesc_t;
}
extern "C" {
    #[doc = " deletion of a spectral descriptor\n\n\\param o spectral descriptor object as returned by new_aubio_specdesc()"]
    pub fn del_aubio_specdesc(o: *mut aubio_specdesc_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_spectral_whitening_t {
    _unused: [u8; 0],
}
#[doc = " spectral whitening structure"]
pub type aubio_spectral_whitening_t = _aubio_spectral_whitening_t;
extern "C" {
    #[doc = " execute spectral adaptive whitening, in-place\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()\n\\param fftgrain input signal spectrum as computed by aubio_pvoc_do() or aubio_fft_do()"]
    pub fn aubio_spectral_whitening_do(o: *mut aubio_spectral_whitening_t, fftgrain: *mut cvec_t);
}
extern "C" {
    #[doc = " creation of a spectral whitening object\n\n\\param buf_size window size of input grains\n\\param hop_size number of samples between two consecutive input grains\n\\param samplerate sampling rate of the input signal"]
    pub fn new_aubio_spectral_whitening(
        buf_size: uint_t,
        hop_size: uint_t,
        samplerate: uint_t,
    ) -> *mut aubio_spectral_whitening_t;
}
extern "C" {
    #[doc = " reset spectral whitening object\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()\n"]
    pub fn aubio_spectral_whitening_reset(o: *mut aubio_spectral_whitening_t);
}
extern "C" {
    #[doc = " set relaxation time for spectral whitening\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()\n\\param relax_time relaxation time in seconds between 20 and 500, defaults 250\n"]
    pub fn aubio_spectral_whitening_set_relax_time(
        o: *mut aubio_spectral_whitening_t,
        relax_time: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " get relaxation time of spectral whitening\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()\n\\return relaxation time in seconds"]
    pub fn aubio_spectral_whitening_get_relax_time(o: *mut aubio_spectral_whitening_t) -> smpl_t;
}
extern "C" {
    #[doc = " set floor for spectral whitening\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()\n\\param floor value (typically between 1.e-6 and .2, defaults to 1.e-4)\n"]
    pub fn aubio_spectral_whitening_set_floor(
        o: *mut aubio_spectral_whitening_t,
        floor: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " get floor of spectral whitening\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()\n\\return floor value"]
    pub fn aubio_spectral_whitening_get_floor(o: *mut aubio_spectral_whitening_t) -> smpl_t;
}
extern "C" {
    #[doc = " deletion of a spectral whitening\n\n\\param o spectral whitening object as returned by new_aubio_spectral_whitening()"]
    pub fn del_aubio_spectral_whitening(o: *mut aubio_spectral_whitening_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_tss_t {
    _unused: [u8; 0],
}
#[doc = " Transient / Steady-state Separation object"]
pub type aubio_tss_t = _aubio_tss_t;
extern "C" {
    #[doc = " create tss object\n\n\\param buf_size buffer size\n\\param hop_size step size"]
    pub fn new_aubio_tss(buf_size: uint_t, hop_size: uint_t) -> *mut aubio_tss_t;
}
extern "C" {
    #[doc = " delete tss object\n\n\\param o tss object as returned by new_aubio_tss()"]
    pub fn del_aubio_tss(o: *mut aubio_tss_t);
}
extern "C" {
    #[doc = " split input into transient and steady states components\n\n\\param o tss object as returned by new_aubio_tss()\n\\param input input spectral frame\n\\param trans output transient components\n\\param stead output steady state components"]
    pub fn aubio_tss_do(
        o: *mut aubio_tss_t,
        input: *const cvec_t,
        trans: *mut cvec_t,
        stead: *mut cvec_t,
    );
}
extern "C" {
    #[doc = " set transient / steady state separation threshold\n\n\\param o tss object as returned by new_aubio_tss()\n\\param thrs new threshold value"]
    pub fn aubio_tss_set_threshold(o: *mut aubio_tss_t, thrs: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set parameter a, defaults to 3\n\n\\param o tss object as returned by new_aubio_tss()\n\\param alpha new value for alpha parameter"]
    pub fn aubio_tss_set_alpha(o: *mut aubio_tss_t, alpha: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set parameter b, defaults to 3\n\n\\param o tss object as returned by new_aubio_tss()\n\\param beta new value for beta parameter"]
    pub fn aubio_tss_set_beta(o: *mut aubio_tss_t, beta: smpl_t) -> uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_pitch_t {
    _unused: [u8; 0],
}
#[doc = " pitch detection object"]
pub type aubio_pitch_t = _aubio_pitch_t;
extern "C" {
    #[doc = " execute pitch detection on an input signal frame\n\n\\param o pitch detection object as returned by new_aubio_pitch()\n\\param in input signal of size [hop_size]\n\\param out output pitch candidates of size [1]"]
    pub fn aubio_pitch_do(o: *mut aubio_pitch_t, in_: *const fvec_t, out: *mut fvec_t);
}
extern "C" {
    #[doc = " change yin or yinfft tolerance threshold\n\n\\param o pitch detection object as returned by new_aubio_pitch()\n\\param tol tolerance default is 0.15 for yin and 0.85 for yinfft"]
    pub fn aubio_pitch_set_tolerance(o: *mut aubio_pitch_t, tol: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get yin or yinfft tolerance threshold\n\n\\param o pitch detection object as returned by new_aubio_pitch()\n\\return tolerance (default is 0.15 for yin and 0.85 for yinfft)"]
    pub fn aubio_pitch_get_tolerance(o: *mut aubio_pitch_t) -> smpl_t;
}
extern "C" {
    #[doc = " deletion of the pitch detection object\n\n\\param o pitch detection object as returned by new_aubio_pitch()"]
    pub fn del_aubio_pitch(o: *mut aubio_pitch_t);
}
extern "C" {
    #[doc = " creation of the pitch detection object\n\n\\param method set pitch detection algorithm\n\\param buf_size size of the input buffer to analyse\n\\param hop_size step size between two consecutive analysis instant\n\\param samplerate sampling rate of the signal\n\n\\return newly created ::aubio_pitch_t"]
    pub fn new_aubio_pitch(
        method: *const char_t,
        buf_size: uint_t,
        hop_size: uint_t,
        samplerate: uint_t,
    ) -> *mut aubio_pitch_t;
}
extern "C" {
    #[doc = " set the output unit of the pitch detection object\n\n\\param o pitch detection object as returned by new_aubio_pitch()\n\\param mode set pitch units for output\n\nmode can be one of \"Hz\", \"midi\", \"cent\", or \"bin\". Defaults to \"Hz\".\n\n\\return 0 if successfull, non-zero otherwise"]
    pub fn aubio_pitch_set_unit(o: *mut aubio_pitch_t, mode: *const char_t) -> uint_t;
}
extern "C" {
    #[doc = " set the silence threshold of the pitch detection object\n\n\\param o pitch detection object as returned by new_aubio_pitch()\n\\param silence level threshold under which pitch should be ignored, in dB\n\n\\return 0 if successfull, non-zero otherwise"]
    pub fn aubio_pitch_set_silence(o: *mut aubio_pitch_t, silence: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set the silence threshold of the pitch detection object\n\n\\param o pitch detection object as returned by ::new_aubio_pitch()\n\n\\return level threshold under which pitch should be ignored, in dB"]
    pub fn aubio_pitch_get_silence(o: *mut aubio_pitch_t) -> smpl_t;
}
extern "C" {
    #[doc = " get the current confidence\n\n\\param o pitch detection object as returned by new_aubio_pitch()\n\n\\return the current confidence of the pitch algorithm"]
    pub fn aubio_pitch_get_confidence(o: *mut aubio_pitch_t) -> smpl_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_onset_t {
    _unused: [u8; 0],
}
#[doc = " onset detection object"]
pub type aubio_onset_t = _aubio_onset_t;
extern "C" {
    #[doc = " create onset detection object\n\n\\param method onset detection type as specified in specdesc.h\n\\param buf_size buffer size for phase vocoder\n\\param hop_size hop size for phase vocoder\n\\param samplerate sampling rate of the input signal\n\n\\return newly created ::aubio_onset_t"]
    pub fn new_aubio_onset(
        method: *const char_t,
        buf_size: uint_t,
        hop_size: uint_t,
        samplerate: uint_t,
    ) -> *mut aubio_onset_t;
}
extern "C" {
    #[doc = " execute onset detection\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param input new audio vector of length hop_size\n\\param onset output vector of length 1, containing 0 if no onset was found,\nand a value equal or greater than 1 otherwise\n\nWhen no onset was detected, the first element of the output vector `onset`\nis set to 0.\n\nWhen an onset is found, the first element of the output vector `onset` is set\nto `offset = 1 + a` where `a` is a number in the range`[0, 1]`.\n\nThe final onset detection time, in samples, can be obtained with\naubio_onset_get_last(). It can also be derived from `offset` as\nfollows:\n\n\\code\nt = total_frames + offset * hop_size - delay\n\\endcode\n\nwhere `total_frames` is the total number of frames processed so far, and\n`delay` is the current delay of the onset object, as returned by\naubio_onset_get_delay()."]
    pub fn aubio_onset_do(o: *mut aubio_onset_t, input: *const fvec_t, onset: *mut fvec_t);
}
extern "C" {
    #[doc = " get the time of the latest onset detected, in samples\n\n\\param o onset detection object as returned by new_aubio_onset()\n\n\\return onset detection timestamps (in samples)"]
    pub fn aubio_onset_get_last(o: *const aubio_onset_t) -> uint_t;
}
extern "C" {
    #[doc = " get the time of the latest onset detected, in seconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\n\\return onset detection timestamps (in seconds)"]
    pub fn aubio_onset_get_last_s(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get the time of the latest onset detected, in milliseconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\n\\return onset detection timestamps (in milliseconds)"]
    pub fn aubio_onset_get_last_ms(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " set onset detection adaptive whitening\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param enable 1 to enable, 0 to disable\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_onset_set_awhitening(o: *mut aubio_onset_t, enable: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " get onset detection adaptive whitening\n\n\\param o onset detection object as returned by new_aubio_onset()\n\n\\return 1 if enabled, 0 otherwise"]
    pub fn aubio_onset_get_awhitening(o: *mut aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " set or disable log compression\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param lambda logarithmic compression factor, 0 to disable\n\n\\return 0 if successful, 1 otherwise\n"]
    pub fn aubio_onset_set_compression(o: *mut aubio_onset_t, lambda: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get onset detection log compression\n\n\\param o onset detection object as returned by new_aubio_onset()\n\n\\returns 0 if disabled, compression factor otherwise\n"]
    pub fn aubio_onset_get_compression(o: *mut aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " set onset detection silence threshold\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param silence new silence detection threshold"]
    pub fn aubio_onset_set_silence(o: *mut aubio_onset_t, silence: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get onset detection silence threshold\n\n\\param o onset detection object as returned by new_aubio_onset()\n\n\\return current silence threshold"]
    pub fn aubio_onset_get_silence(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get onset detection function\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return the current value of the descriptor"]
    pub fn aubio_onset_get_descriptor(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get thresholded onset detection function\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return the value of the thresholded descriptor"]
    pub fn aubio_onset_get_thresholded_descriptor(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " set onset detection peak picking threshold\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param threshold new peak-picking threshold"]
    pub fn aubio_onset_set_threshold(o: *mut aubio_onset_t, threshold: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set minimum inter onset interval in samples\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param minioi minimum interval between two consecutive onsets (in\nsamples)"]
    pub fn aubio_onset_set_minioi(o: *mut aubio_onset_t, minioi: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " set minimum inter onset interval in seconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param minioi minimum interval between two consecutive onsets (in\nseconds)"]
    pub fn aubio_onset_set_minioi_s(o: *mut aubio_onset_t, minioi: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set minimum inter onset interval in milliseconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param minioi minimum interval between two consecutive onsets (in\nmilliseconds)"]
    pub fn aubio_onset_set_minioi_ms(o: *mut aubio_onset_t, minioi: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set delay in samples\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param delay constant system delay to take back from detection time\n(in samples)"]
    pub fn aubio_onset_set_delay(o: *mut aubio_onset_t, delay: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " set delay in seconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param delay constant system delay to take back from detection time\n(in seconds)"]
    pub fn aubio_onset_set_delay_s(o: *mut aubio_onset_t, delay: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set delay in milliseconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param delay constant system delay to take back from detection time\n(in milliseconds)"]
    pub fn aubio_onset_set_delay_ms(o: *mut aubio_onset_t, delay: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get minimum inter onset interval in samples\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return minimum interval between two consecutive onsets (in\nsamples)"]
    pub fn aubio_onset_get_minioi(o: *const aubio_onset_t) -> uint_t;
}
extern "C" {
    #[doc = " get minimum inter onset interval in seconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return minimum interval between two consecutive onsets (in\nseconds)"]
    pub fn aubio_onset_get_minioi_s(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get minimum inter onset interval in milliseconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return minimum interval between two consecutive onsets (in\nmilliseconds)"]
    pub fn aubio_onset_get_minioi_ms(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get delay in samples\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return constant system delay to take back from detection time\n(in samples)"]
    pub fn aubio_onset_get_delay(o: *const aubio_onset_t) -> uint_t;
}
extern "C" {
    #[doc = " get delay in seconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return constant system delay to take back from detection time\n(in seconds)"]
    pub fn aubio_onset_get_delay_s(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get delay in milliseconds\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return constant system delay to take back from detection time\n(in milliseconds)"]
    pub fn aubio_onset_get_delay_ms(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " get onset peak picking threshold\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\return current onset detection threshold"]
    pub fn aubio_onset_get_threshold(o: *const aubio_onset_t) -> smpl_t;
}
extern "C" {
    #[doc = " set default parameters\n\n\\param o onset detection object as returned by new_aubio_onset()\n\\param onset_mode detection mode to adjust\n\nThis function is called at the end of new_aubio_onset().\n"]
    pub fn aubio_onset_set_default_parameters(
        o: *mut aubio_onset_t,
        onset_mode: *const char_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " reset onset detection\n\n\\param o onset detection object as returned by new_aubio_onset()\n\nReset current time and last onset to 0.\n\nThis function is called at the end of new_aubio_onset().\n"]
    pub fn aubio_onset_reset(o: *mut aubio_onset_t);
}
extern "C" {
    #[doc = " delete onset detection object\n\n\\param o onset detection object to delete"]
    pub fn del_aubio_onset(o: *mut aubio_onset_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_tempo_t {
    _unused: [u8; 0],
}
#[doc = " tempo detection structure"]
pub type aubio_tempo_t = _aubio_tempo_t;
extern "C" {
    #[doc = " create tempo detection object\n\n\\param method beat tracking method, unused for now (use \"default\")\n\\param buf_size length of FFT\n\\param hop_size number of frames between two consecutive runs\n\\param samplerate sampling rate of the signal to analyze\n\n\\return newly created ::aubio_tempo_t if successful, `NULL` otherwise"]
    pub fn new_aubio_tempo(
        method: *const char_t,
        buf_size: uint_t,
        hop_size: uint_t,
        samplerate: uint_t,
    ) -> *mut aubio_tempo_t;
}
extern "C" {
    #[doc = " execute tempo detection\n\n\\param o beat tracking object\n\\param input new samples\n\\param tempo output beats"]
    pub fn aubio_tempo_do(o: *mut aubio_tempo_t, input: *const fvec_t, tempo: *mut fvec_t);
}
extern "C" {
    #[doc = " get the time of the latest beat detected, in samples\n\n\\param o tempo detection object as returned by ::new_aubio_tempo"]
    pub fn aubio_tempo_get_last(o: *mut aubio_tempo_t) -> uint_t;
}
extern "C" {
    #[doc = " get the time of the latest beat detected, in seconds\n\n\\param o tempo detection object as returned by ::new_aubio_tempo"]
    pub fn aubio_tempo_get_last_s(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get the time of the latest beat detected, in milliseconds\n\n\\param o tempo detection object as returned by ::new_aubio_tempo"]
    pub fn aubio_tempo_get_last_ms(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " set tempo detection silence threshold\n\n\\param o beat tracking object\n\\param silence new silence threshold, in dB\n\n\\return `0` if successful, non-zero otherwise"]
    pub fn aubio_tempo_set_silence(o: *mut aubio_tempo_t, silence: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get tempo detection silence threshold\n\n\\param o tempo detection object as returned by new_aubio_tempo()\n\n\\return current silence threshold"]
    pub fn aubio_tempo_get_silence(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " set tempo detection peak picking threshold\n\n\\param o beat tracking object\n\\param threshold new threshold\n\n\\return `0` if successful, non-zero otherwise"]
    pub fn aubio_tempo_set_threshold(o: *mut aubio_tempo_t, threshold: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get tempo peak picking threshold\n\n\\param o tempo detection object as returned by new_aubio_tempo()\n\n\\return current tempo detection threshold"]
    pub fn aubio_tempo_get_threshold(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current beat period in samples\n\n\\param bt beat tracking object\n\nReturns the currently observed period, in samples, or 0 if no consistent\nvalue is found."]
    pub fn aubio_tempo_get_period(bt: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current beat period in seconds\n\n\\param bt beat tracking object\n\nReturns the currently observed period, in seconds, or 0 if no consistent\nvalue is found."]
    pub fn aubio_tempo_get_period_s(bt: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current tempo\n\n\\param o beat tracking object\n\n\\return the currently observed tempo, or `0` if no consistent value is found"]
    pub fn aubio_tempo_get_bpm(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current tempo confidence\n\n\\param o beat tracking object\n\n\\return confidence with which the tempo has been observed, the higher the\nmore confidence, `0` if no consistent value is found."]
    pub fn aubio_tempo_get_confidence(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " set number of tatum per beat\n\n\\param o beat tracking object\n\\param signature number of tatum per beat (between 1 and 64)"]
    pub fn aubio_tempo_set_tatum_signature(o: *mut aubio_tempo_t, signature: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " check whether a tatum was detected in the current frame\n\n\\param o beat tracking object\n\n\\return 2 if a beat was detected, 1 if a tatum was detected, 0 otherwise"]
    pub fn aubio_tempo_was_tatum(o: *mut aubio_tempo_t) -> uint_t;
}
extern "C" {
    #[doc = " get position of last_tatum, in samples\n\n\\param o beat tracking object"]
    pub fn aubio_tempo_get_last_tatum(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current delay\n\n\\param o beat tracking object\n\n\\return current delay, in samples\n"]
    pub fn aubio_tempo_get_delay(o: *mut aubio_tempo_t) -> uint_t;
}
extern "C" {
    #[doc = " get current delay in seconds\n\n\\param o beat tracking object\n\n\\return current delay, in seconds\n"]
    pub fn aubio_tempo_get_delay_s(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current delay in ms\n\n\\param o beat tracking object\n\n\\return current delay, in milliseconds\n"]
    pub fn aubio_tempo_get_delay_ms(o: *mut aubio_tempo_t) -> smpl_t;
}
extern "C" {
    #[doc = " set current delay\n\n\\param o beat tracking object\n\\param delay delay to set tempo to, in samples\n\n\\return `0` if successful, non-zero otherwise\n"]
    pub fn aubio_tempo_set_delay(o: *mut aubio_tempo_t, delay: sint_t) -> uint_t;
}
extern "C" {
    #[doc = " set current delay in seconds\n\n\\param o beat tracking object\n\\param delay delay to set tempo to, in seconds\n\n\\return `0` if successful, non-zero otherwise\n"]
    pub fn aubio_tempo_set_delay_s(o: *mut aubio_tempo_t, delay: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " set current delay\n\n\\param o beat tracking object\n\\param delay delay to set tempo to, in samples\n\n\\return `0` if successful, non-zero otherwise\n"]
    pub fn aubio_tempo_set_delay_ms(o: *mut aubio_tempo_t, delay: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " delete tempo detection object\n\n\\param o beat tracking object"]
    pub fn del_aubio_tempo(o: *mut aubio_tempo_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_notes_t {
    _unused: [u8; 0],
}
#[doc = " notes detection object"]
pub type aubio_notes_t = _aubio_notes_t;
extern "C" {
    #[doc = " create notes detection object\n\n\\param method notes detection type as specified in specdesc.h\n\\param buf_size buffer size for phase vocoder\n\\param hop_size hop size for phase vocoder\n\\param samplerate sampling rate of the input signal\n\n\\return newly created ::aubio_notes_t"]
    pub fn new_aubio_notes(
        method: *const char_t,
        buf_size: uint_t,
        hop_size: uint_t,
        samplerate: uint_t,
    ) -> *mut aubio_notes_t;
}
extern "C" {
    #[doc = " delete notes detection object\n\n\\param o notes detection object to delete"]
    pub fn del_aubio_notes(o: *mut aubio_notes_t);
}
extern "C" {
    #[doc = " execute note detection on an input signal frame\n\n\\param o note detection object as returned by new_aubio_notes()\n\\param input input signal of size [hop_size]\n\\param output output notes, fvec of length 3\n\nThe notes output is a vector of length 3 containing:\n- 0. the midi note value, or 0 if no note was found\n- 1. the note velocity\n- 2. the midi note to turn off"]
    pub fn aubio_notes_do(o: *mut aubio_notes_t, input: *const fvec_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " set notes detection silence threshold\n\n\\param o notes detection object as returned by new_aubio_notes()\n\\param silence new silence detection threshold\n\n\\return 0 on success, non-zero otherwise"]
    pub fn aubio_notes_set_silence(o: *mut aubio_notes_t, silence: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get notes detection silence threshold\n\n\\param o notes detection object as returned by new_aubio_notes()\n\n\\return current silence threshold"]
    pub fn aubio_notes_get_silence(o: *const aubio_notes_t) -> smpl_t;
}
extern "C" {
    #[doc = " get notes detection minimum inter-onset interval, in millisecond\n\n\\param o notes detection object as returned by new_aubio_notes()\n\n\\return current minimum inter onset interval\n"]
    pub fn aubio_notes_get_minioi_ms(o: *const aubio_notes_t) -> smpl_t;
}
extern "C" {
    #[doc = " set notes detection minimum inter-onset interval, in millisecond\n\n\\param o notes detection object as returned by new_aubio_notes()\n\\param minioi_ms new inter-onset interval\n\n\\return 0 on success, non-zero otherwise"]
    pub fn aubio_notes_set_minioi_ms(o: *mut aubio_notes_t, minioi_ms: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get notes object release drop level, in dB\n\n\\param o notes detection object as returned by new_aubio_notes()\n\n\\return current release drop level, in dB\n"]
    pub fn aubio_notes_get_release_drop(o: *const aubio_notes_t) -> smpl_t;
}
extern "C" {
    #[doc = " set note release drop level, in dB\n\nThis function sets the release_drop_level parameter, in dB. When a new note\nis found, the current level in dB is measured. If the measured level drops\nunder that initial level - release_drop_level, then a note-off will be\nemitted.\n\nDefaults to `10`, in dB.\n\n\\note This parameter was added in version `0.4.8`. Results obtained with\nearlier versions can be reproduced by setting this value to `100`, so that\nnote-off will not be played until the next note.\n\n\\param o notes detection object as returned by new_aubio_notes()\n\\param release_drop new release drop level, in dB\n\n\\return 0 on success, non-zero otherwise"]
    pub fn aubio_notes_set_release_drop(o: *mut aubio_notes_t, release_drop: smpl_t) -> uint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_source_t {
    _unused: [u8; 0],
}
#[doc = " media source object"]
pub type aubio_source_t = _aubio_source_t;
extern "C" {
    #[doc = "create new ::aubio_source_t\n\n\\param uri the file path or uri to read from\n\\param samplerate sampling rate to view the fie at\n\\param hop_size the size of the blocks to read from\n\nCreates a new source object. If `0` is passed as `samplerate`, the sample\nrate of the original file is used.\n\nThe samplerate of newly created source can be obtained using\n::aubio_source_get_samplerate."]
    pub fn new_aubio_source(
        uri: *const char_t,
        samplerate: uint_t,
        hop_size: uint_t,
    ) -> *mut aubio_source_t;
}
extern "C" {
    #[doc = "read monophonic vector of length hop_size from source object\n\n\\param s source object, created with ::new_aubio_source\n\\param read_to ::fvec_t of data to read to\n\\param read upon returns, equals to number of frames actually read\n\nUpon returns, `read` contains the number of frames actually read from the\nsource. `hop_size` if enough frames could be read, less otherwise."]
    pub fn aubio_source_do(s: *mut aubio_source_t, read_to: *mut fvec_t, read: *mut uint_t);
}
extern "C" {
    #[doc = "read polyphonic vector of length hop_size from source object\n\n\\param s source object, created with ::new_aubio_source\n\\param read_to ::fmat_t of data to read to\n\\param[out] read upon returns, equals to number of frames actually read\n\nUpon returns, `read` contains the number of frames actually read from the\nsource. `hop_size` if enough frames could be read, less otherwise."]
    pub fn aubio_source_do_multi(s: *mut aubio_source_t, read_to: *mut fmat_t, read: *mut uint_t);
}
extern "C" {
    #[doc = "get samplerate of source object\n\n\\param s source object, created with ::new_aubio_source\n\\return samplerate, in Hz"]
    pub fn aubio_source_get_samplerate(s: *mut aubio_source_t) -> uint_t;
}
extern "C" {
    #[doc = "get channels of source object\n\n\\param s source object, created with ::new_aubio_source\n\\return channels"]
    pub fn aubio_source_get_channels(s: *mut aubio_source_t) -> uint_t;
}
extern "C" {
    #[doc = "seek source object\n\n\\param s source object, created with ::new_aubio_source\n\\param pos position to seek to, in frames\n\n\\return 0 if sucessful, non-zero on failure"]
    pub fn aubio_source_seek(s: *mut aubio_source_t, pos: uint_t) -> uint_t;
}
extern "C" {
    #[doc = "get the duration of source object, in frames\n\n\\param s source object, created with ::new_aubio_source\n\\return number of frames in file"]
    pub fn aubio_source_get_duration(s: *mut aubio_source_t) -> uint_t;
}
extern "C" {
    #[doc = "close source object\n\n\\param s source object, created with ::new_aubio_source\n\n\\return 0 if sucessful, non-zero on failure\n"]
    pub fn aubio_source_close(s: *mut aubio_source_t) -> uint_t;
}
extern "C" {
    #[doc = "close source and cleanup memory\n\n\\param s source object, created with ::new_aubio_source"]
    pub fn del_aubio_source(s: *mut aubio_source_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_sink_t {
    _unused: [u8; 0],
}
#[doc = " media sink object"]
pub type aubio_sink_t = _aubio_sink_t;
extern "C" {
    #[doc = "create new ::aubio_sink_t\n\n\\param uri the file path or uri to write to\n\\param samplerate sample rate to write the file at\n\n\\return newly created ::aubio_sink_t\n\nCreates a new sink object.\n\nIf samplerate is set to 0, the creation of the file will be delayed until\nboth ::aubio_sink_preset_samplerate and ::aubio_sink_preset_channels have\nbeen called."]
    pub fn new_aubio_sink(uri: *const char_t, samplerate: uint_t) -> *mut aubio_sink_t;
}
extern "C" {
    #[doc = "preset sink samplerate\n\n\\param s sink, created with ::new_aubio_sink\n\\param samplerate samplerate to preset the sink to, in Hz\n\n\\return 0 on success, 1 on error\n\nPreset the samplerate of the sink. The file should have been created using a\nsamplerate of 0.\n\nThe file will be opened only when both samplerate and channels have been set."]
    pub fn aubio_sink_preset_samplerate(s: *mut aubio_sink_t, samplerate: uint_t) -> uint_t;
}
extern "C" {
    #[doc = "preset sink channels\n\n\\param s sink, created with ::new_aubio_sink\n\\param channels number of channels to preset the sink to\n\n\\return 0 on success, 1 on error\n\nPreset the samplerate of the sink. The file should have been created using a\nsamplerate of 0.\n\nThe file will be opened only when both samplerate and channels have been set."]
    pub fn aubio_sink_preset_channels(s: *mut aubio_sink_t, channels: uint_t) -> uint_t;
}
extern "C" {
    #[doc = "get samplerate of sink object\n\n\\param s sink object, created with ::new_aubio_sink\n\\return samplerate, in Hz"]
    pub fn aubio_sink_get_samplerate(s: *const aubio_sink_t) -> uint_t;
}
extern "C" {
    #[doc = "get channels of sink object\n\n\\param s sink object, created with ::new_aubio_sink\n\\return number of channels"]
    pub fn aubio_sink_get_channels(s: *const aubio_sink_t) -> uint_t;
}
extern "C" {
    #[doc = "write monophonic vector of length hop_size to sink\n\n\\param s sink, created with ::new_aubio_sink\n\\param write_data ::fvec_t samples to write to sink\n\\param write number of frames to write"]
    pub fn aubio_sink_do(s: *mut aubio_sink_t, write_data: *mut fvec_t, write: uint_t);
}
extern "C" {
    #[doc = "write polyphonic vector of length hop_size to sink\n\n\\param s sink, created with ::new_aubio_sink\n\\param write_data ::fmat_t samples to write to sink\n\\param write number of frames to write"]
    pub fn aubio_sink_do_multi(s: *mut aubio_sink_t, write_data: *mut fmat_t, write: uint_t);
}
extern "C" {
    #[doc = "close sink\n\n\\param s sink object, created with ::new_aubio_sink\n\n\\return 0 on success, non-zero on failure"]
    pub fn aubio_sink_close(s: *mut aubio_sink_t) -> uint_t;
}
extern "C" {
    #[doc = "close sink and cleanup memory\n\n\\param s sink object, created with ::new_aubio_sink"]
    pub fn del_aubio_sink(s: *mut aubio_sink_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_sampler_t {
    _unused: [u8; 0],
}
#[doc = " sampler object"]
pub type aubio_sampler_t = _aubio_sampler_t;
extern "C" {
    #[doc = " create new sampler object\n\n\\param samplerate the sampling rate of the new sampler\n\\param hop_size the block size of the new sampler\n\n\\return the newly created ::aubio_sampler_t"]
    pub fn new_aubio_sampler(samplerate: uint_t, hop_size: uint_t) -> *mut aubio_sampler_t;
}
extern "C" {
    #[doc = " load source in sampler\n\n\\param o sampler, created by new_aubio_sampler()\n\\param uri the uri of the source to load\n\n\\return 0 if successful, non-zero otherwise"]
    pub fn aubio_sampler_load(o: *mut aubio_sampler_t, uri: *const char_t) -> uint_t;
}
extern "C" {
    #[doc = " process sampler function\n\n\\param o sampler, created by new_aubio_sampler()\n\\param input input of the sampler, to be added to the output\n\\param output output of the sampler\n\nThis function adds the new samples from the playing source to the output.\n\nIf `input` is not NULL and different from `output`, then the samples from `input`\nare added to the output."]
    pub fn aubio_sampler_do(o: *mut aubio_sampler_t, input: *const fvec_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " process sampler function, multiple channels\n\n\\param o sampler, created by new_aubio_sampler()\n\\param input input of the sampler, to be added to the output\n\\param output output of the sampler\n\nThis function adds the new samples from the playing source to the output.\n\nIf `input` is not NULL and different from `output`, then the samples from `input`\nare added to the output."]
    pub fn aubio_sampler_do_multi(
        o: *mut aubio_sampler_t,
        input: *const fmat_t,
        output: *mut fmat_t,
    );
}
extern "C" {
    #[doc = " get current playing state\n\n\\param o sampler, created by new_aubio_sampler()\n\n\\return 0 if not playing, 1 if playing"]
    pub fn aubio_sampler_get_playing(o: *const aubio_sampler_t) -> uint_t;
}
extern "C" {
    #[doc = " set current playing state\n\n\\param o sampler, created by new_aubio_sampler()\n\\param playing 0 for not playing, 1 for playing\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_sampler_set_playing(o: *mut aubio_sampler_t, playing: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " play sample from start\n\n\\param o sampler, created by new_aubio_sampler()\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_sampler_play(o: *mut aubio_sampler_t) -> uint_t;
}
extern "C" {
    #[doc = " stop sample\n\n\\param o sampler, created by new_aubio_sampler()\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_sampler_stop(o: *mut aubio_sampler_t) -> uint_t;
}
extern "C" {
    #[doc = " destroy ::aubio_sampler_t object\n\n\\param o sampler, created by new_aubio_sampler()"]
    pub fn del_aubio_sampler(o: *mut aubio_sampler_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_wavetable_t {
    _unused: [u8; 0],
}
#[doc = " wavetable object"]
pub type aubio_wavetable_t = _aubio_wavetable_t;
extern "C" {
    #[doc = " create new wavetable object\n\n\\param samplerate the sampling rate of the new wavetable\n\\param hop_size the block size of the new wavetable\n\n\\return the newly created aubio_wavetable_t"]
    pub fn new_aubio_wavetable(samplerate: uint_t, hop_size: uint_t) -> *mut aubio_wavetable_t;
}
extern "C" {
    #[doc = " load source in wavetable\n\nTODO: This function is not implemented yet. See new_aubio_sampler() instead.\n\n\\param o wavetable, created by new_aubio_wavetable()\n\\param uri the uri of the source to load\n\n\\return 0 if successful, non-zero otherwise"]
    pub fn aubio_wavetable_load(o: *mut aubio_wavetable_t, uri: *const char_t) -> uint_t;
}
extern "C" {
    #[doc = " process wavetable function\n\n\\param o wavetable, created by new_aubio_wavetable()\n\\param input input of the wavetable, to be added to the output\n\\param output output of the wavetable\n\nThis function adds the new samples from the playing wavetable to the output.\n\nIf `input` is not NULL and different from `output`, then the samples from `input`\nare added to the output."]
    pub fn aubio_wavetable_do(o: *mut aubio_wavetable_t, input: *const fvec_t, output: *mut fvec_t);
}
extern "C" {
    #[doc = " process wavetable function, multiple channels\n\n\\param o wavetable, created by new_aubio_wavetable()\n\\param input input of the wavetable, to be added to the output\n\\param output output of the wavetable\n\nThis function adds the new samples from the playing wavetable to the output.\n\nIf `input` is not NULL and different from `output`, then the samples from `input`\nare added to the output."]
    pub fn aubio_wavetable_do_multi(
        o: *mut aubio_wavetable_t,
        input: *const fmat_t,
        output: *mut fmat_t,
    );
}
extern "C" {
    #[doc = " get current playing state\n\n\\param o wavetable, created by new_aubio_wavetable()\n\n\\return 0 if not playing, 1 if playing"]
    pub fn aubio_wavetable_get_playing(o: *const aubio_wavetable_t) -> uint_t;
}
extern "C" {
    #[doc = " set current playing state\n\n\\param o wavetable, created by new_aubio_wavetable()\n\\param playing 0 for not playing, 1 for playing\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_wavetable_set_playing(o: *mut aubio_wavetable_t, playing: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " play sample from start\n\n\\param o wavetable, created by new_aubio_wavetable()\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_wavetable_play(o: *mut aubio_wavetable_t) -> uint_t;
}
extern "C" {
    #[doc = " stop wavetable\n\n\\param o wavetable, created by new_aubio_wavetable()\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_wavetable_stop(o: *mut aubio_wavetable_t) -> uint_t;
}
extern "C" {
    #[doc = " set wavetable frequency\n\n\\param o wavetable, created by new_aubio_wavetable()\n\\param freq new frequency value for the wavetable\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_wavetable_set_freq(o: *mut aubio_wavetable_t, freq: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get wavetable frequency\n\n\\param o wavetable, created by new_aubio_wavetable()\n\n\\return current frequency, in Hz"]
    pub fn aubio_wavetable_get_freq(o: *const aubio_wavetable_t) -> smpl_t;
}
extern "C" {
    #[doc = " set wavetable amplitude\n\n\\param o wavetable, created by new_aubio_wavetable()\n\\param amp new amplitude value for the wavetable\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_wavetable_set_amp(o: *mut aubio_wavetable_t, amp: smpl_t) -> uint_t;
}
extern "C" {
    #[doc = " get wavetable amplitude\n\n\\param o wavetable, created by new_aubio_wavetable()\n\n\\return current amplitude"]
    pub fn aubio_wavetable_get_amp(o: *const aubio_wavetable_t) -> smpl_t;
}
extern "C" {
    #[doc = " destroy aubio_wavetable_t object\n\n\\param o wavetable, created by new_aubio_wavetable()"]
    pub fn del_aubio_wavetable(o: *mut aubio_wavetable_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _aubio_parameter_t {
    _unused: [u8; 0],
}
#[doc = " parameter object"]
pub type aubio_parameter_t = _aubio_parameter_t;
extern "C" {
    #[doc = " create new parameter object\n\n\\param min_value the minimum value of the new parameter\n\\param max_value the maximum value of the new parameter\n\\param steps the number of steps to interpolate from the old value to the target value\n\n\\return the newly created ::aubio_parameter_t"]
    pub fn new_aubio_parameter(
        min_value: smpl_t,
        max_value: smpl_t,
        steps: uint_t,
    ) -> *mut aubio_parameter_t;
}
extern "C" {
    #[doc = " set target value of the parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\\param value new target value\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_parameter_set_target_value(param: *mut aubio_parameter_t, value: smpl_t)
        -> uint_t;
}
extern "C" {
    #[doc = " get next parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\n\\return new interpolated parameter value"]
    pub fn aubio_parameter_get_next_value(param: *mut aubio_parameter_t) -> smpl_t;
}
extern "C" {
    #[doc = " get current parameter value, without interpolation\n\n\\param param parameter, created by ::new_aubio_parameter\n\n\\return current value"]
    pub fn aubio_parameter_get_current_value(param: *const aubio_parameter_t) -> smpl_t;
}
extern "C" {
    #[doc = " set current parameter value, skipping interpolation\n\n\\param param parameter, created by ::new_aubio_parameter\n\\param value new parameter value\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_parameter_set_current_value(
        param: *mut aubio_parameter_t,
        value: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " set number of steps used for interpolation\n\n\\param param parameter, created by ::new_aubio_parameter\n\\param steps new number of steps\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_parameter_set_steps(param: *mut aubio_parameter_t, steps: uint_t) -> uint_t;
}
extern "C" {
    #[doc = " get number of steps of this parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\n\\return number of steps"]
    pub fn aubio_parameter_get_steps(param: *const aubio_parameter_t) -> uint_t;
}
extern "C" {
    #[doc = " set minimum value of this parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\\param min_value new minimum value\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_parameter_set_min_value(
        param: *mut aubio_parameter_t,
        min_value: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " get minimum value of this parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\n\\return minimum value"]
    pub fn aubio_parameter_get_min_value(param: *const aubio_parameter_t) -> smpl_t;
}
extern "C" {
    #[doc = " set maximum value of this parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\\param max_value new maximum value\n\n\\return 0 if successful, 1 otherwise"]
    pub fn aubio_parameter_set_max_value(
        param: *mut aubio_parameter_t,
        max_value: smpl_t,
    ) -> uint_t;
}
extern "C" {
    #[doc = " get maximum value of this parameter\n\n\\param param parameter, created by ::new_aubio_parameter\n\n\\return maximum value"]
    pub fn aubio_parameter_get_max_value(param: *const aubio_parameter_t) -> smpl_t;
}
extern "C" {
    #[doc = " destroy ::aubio_parameter_t object\n\n\\param param parameter, created by ::new_aubio_parameter"]
    pub fn del_aubio_parameter(param: *mut aubio_parameter_t);
}
#[doc = "< critical errors"]
pub const aubio_log_level_AUBIO_LOG_ERR: aubio_log_level = 0;
#[doc = "< infos"]
pub const aubio_log_level_AUBIO_LOG_INF: aubio_log_level = 1;
#[doc = "< general messages"]
pub const aubio_log_level_AUBIO_LOG_MSG: aubio_log_level = 2;
#[doc = "< debug messages"]
pub const aubio_log_level_AUBIO_LOG_DBG: aubio_log_level = 3;
#[doc = "< warnings"]
pub const aubio_log_level_AUBIO_LOG_WRN: aubio_log_level = 4;
#[doc = "< number of valid levels"]
pub const aubio_log_level_AUBIO_LOG_LAST_LEVEL: aubio_log_level = 5;
#[doc = " list of logging levels"]
pub type aubio_log_level = ::std::os::raw::c_uint;
#[doc = " Logging function prototype, to be passed to ::aubio_log_set_function\n\n\\param level log level\n\\param message text to log\n\\param data optional closure used by the callback\n\nSee @ref utils/test-log.c for an example of logging function.\n"]
pub type aubio_log_function_t = ::std::option::Option<
    unsafe extern "C" fn(level: sint_t, message: *const char_t, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Set logging function for all levels\n\n\\param fun the function to be used to log, of type ::aubio_log_function_t\n\\param data optional closure to be passed to the function (can be NULL if\nnothing to pass)\n"]
    pub fn aubio_log_set_function(fun: aubio_log_function_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Set logging function for a given level\n\n\\param level the level for which to set the logging function\n\\param fun the function to be used to log, of type ::aubio_log_function_t\n\\param data optional closure to be passed to the function (can be NULL if\nnothing to pass)"]
    pub fn aubio_log_set_level_function(
        level: sint_t,
        fun: aubio_log_function_t,
        data: *mut ::std::os::raw::c_void,
    ) -> aubio_log_function_t;
}
extern "C" {
    #[doc = " Reset all logging functions to the default one\n\nAfter calling this function, the default logging function will be used to\nprint error, warning, normal, and debug messages to `stdout` or `stderr`.\n"]
    pub fn aubio_log_reset();
}
